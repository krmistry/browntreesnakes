---
title: "Individual-based Generating Model"
author: "Kelly Mistry"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(reshape2)
library(ggplot2)
library(dplyr)
```

## Individual-based Generating Model

Initial conditions and rough model structure:

-   25 individuals to start (to run faster)

-   Time step is days

-   In each time step, each individual:

    -   Has a probability of growing (Poisson based on the Gompertz growth function? Not quite sure yet, start with a static value as the Poisson lambda)

        -   Maybe this should be a Bernoulli too - sometimes there's no growth, and that could be relatively easy to add density dependence to; $p$ would change based on the density, so the probability of growing at all changes, independent of the actual growth rate

    -   Has a probability of reproducing (Bernoulli, then Poisson for number of offspring? Or just Poisson?)

        -   Same as for growth, having a Bernoulli element might make density dependence easier to incorporate

    -   Has a probability of dying from natural causes (Bernoulli)

-   Initial run time is 90 days (\~1 quarter); may need to run it longer to get much population movement, but start with this

```{r growth_function}

## This first version has linear growth, and the entire function will probably change when I get around to making growth non-linear (with the Gompertz functions from the growth paper)

## Inputs
# small - 1 snake, i.e. one row of dataframe of current population (columns are ID, sex and size)
# density_prob - probability (0 - 1) for the Bernoulli probability for whether or not growth occurs
# growth_rates - dataframe of 3 linear growth rates (for small, medium and large snakes' growth) for each sex, constructed using Nafus et al. 2021 values ---- THIS WILL CHANGE


## Growth rates for linear, size-based growth (based on Nafus et al. 2021 rates, which were distinct for these size bins: <750, 750 - 1000 and >1000 (different from my size bins)
growth_rate <- as.data.frame(matrix(NA, nrow = 3, ncol = 2, 
                                    dimnames = list(c("small", "medium", "large"),
                                                    c("M", "F"))))
growth_rate[1, ] <- c(1.18, 0.98) # less than 750 mm SVL
growth_rate[2, ] <- c(0.56, 0.46) # 750 - 999
growth_rate[3, ] <- c(0.52, 0.29) # greater than or equal to 1,000 

daily_growth_fun <- function(snake, 
                             density_prob,
                             growth_rate) {
  if (rbinom(1, 1, prob = density_prob) == 1) {
      if (snake$SVL < 750) {
        if (snake$sex == "M") {
          snake$SVL <- snake$SVL + growth_rate[1, 1]
        } else {
          snake$SVL <- snake$SVL + growth_rate[1, 2]
        }
      } else if (snake$SVL >= 750 & snake$SVL < 1000) {
        if (snake$sex == "M") {
          snake$SVL <- snake$SVL + growth_rate[2, 1]
        } else {
          snake$SVL <- snake$SVL + growth_rate[2, 2]
        }
      } else {
        if (snake$sex == "M") {
          snake$SVL <- snake$SVL + growth_rate[3, 1]
        } else {
          snake$SVL <- snake$SVL + growth_rate[3, 2]
        }
      }
    } else {
      snake$SVL <- snake$SVL
    }
  return(snake)
}


# Test
# daily_growth_fun(timeseries_pop[[1]][1, ], 
#                             0.75,
#                             growth_rate)

```

```{r reproduction_fun}

## Reproduction - occurs every 90 days; two ways to do this, either in one step or two. In the two step version, the first step is do they reproduce? Then, if they do, the number of offspring comes from a Poisson distribution. Same as with growth, this might make density dependence easier to incorporate by doing this in the first step. Alternatively, this could be done in a single step, with a draw from a Poisson, after isolating the females that could reproduce size-wise

## Each step needs its own function (so that the females not selected to reproduce can stay in the general population and go through the growth and mortality for loop)

#### First reproduction function: extracting females that will reproduce in this quarter

## Inputs
# start_pop <- dataframe of population at the start of the quarter (columns are ID, sex and size)
# density_prob - probability (0 - 1) for the Bernoulli probability for whether or not snake reproduces in this quarter


repro_females_fun <- function(start_pop,
                             density_prob) {
  # Extracting the females from this population
  females <- start_pop[start_pop$sex == "F",]
  # Setting up the probability of reproduction for each snake based on their size
  # For now, it's based on Savidge et al. 2007 findings, which indicated that 90% of female   snakes reached sexual maturity between 910 and 1,025 SVL (doesn't mean that each            snake has a 90% probability of reproducing in that quarter though - LOOK AT THIS   AGAIN    LATER, it definitely needs to be revised)
  for(snake in 1:nrow(females)) {
    if(females$SVL[snake] < 910) {
      females$repro_prob[snake] <- 0
    } else if (females$SVL[snake] >= 910 & females$SVL[snake] < 1025) {
      females$repro_prob[snake] <- 0.9
    } else {
      females$repro_prob[snake] <- 1
    }
  }
  # Two step version, with a coin flip for whether or not reproduction occurs
  for(snake in 1:nrow(females)) {
  # Coin flip of whether reproduction occurs is based on both density dependence and the     probablity that the individual snake will be able to reproduce based on it's size
    if (rbinom(1, 1, prob = r_density_prob*females$repro_prob[snake]) == 1) {
      females$mom_status[snake] <- 1
    } else {
      females$mom_status[snake] <- 0
    }
  }
  moms <- females[females$mom_status == 1,]
  return(moms[c(1:3)])
}

### Inputs
# mom_pop - dataframe of reproducing female population at the start of the quarter (columns are ID, sex and size)
# time_step - the (numeric) quarter the loop is running, used to help randomly assign IDs

gen_offspring_fun <- function(mom_pop,
                           time_step) {
  # Version one - using the same value for lambda for all sizes (could separate this out      into size buckets, or maybe even could make it continuous based on Nafus data)
  total_offspring <- sum(rpois(nrow(mom_pop), 2.3))
  # Creating empty dataframe to put offspring data into
  offspring <- as.data.frame(matrix(NA, nrow = total_offspring, ncol = 3))
  colnames(offspring) <- c("ID", "SVL", "sex")
  # Filling in IDs, hatchling size (with some variation) and random sex
  if(time_step <= 26) {
    offspring$ID <- paste0(letters[time_step + 1], 
                           sample(1000:9000, total_offspring))
  } else if(time_step > 26 & time_step <= 52) {
    offspring$ID <- paste0(letters[1], 
                           letters[time_step - 26], 
                           sample(1000:9000, total_offspring))
  } else if(time_step > 52 & time_step <= 78) {
    offspring$ID <- paste0(letters[2], 
                           letters[time_step - 52],
                           sample(1000:9000, total_offspring))
  } else {
    offspring$ID <- paste0(letters[3],
                           letters[time_step - 78],
                           sample(1000:9000, total_offspring))
  }
  
  offspring$SVL <- sample(350:400, total_offspring, replace = T)
  offspring$sex <- sample(c("M", "F"), total_offspring, replace = T)
  
  ## Combining the offspring with mothers and return as one dataframe
  return(offspring)
}  


# Test
# x <- repro_function(timeseries_pop[[1]],
#                0.75)


```

```{r mortality_fun}

# Function to incorporate daily mortality rate (completely arbitrary linear rates for now, based on my original size classes)

## Natural mortality - using one day timeseries (post-growth) and size-based mortality rates (current version is that the probability is constant for each of the size-structured model size bins, and the first version here is totally arbitrary)

### Inputs
# pop - dataframe of population (columns are ID, sex and size)
# mortality_rate - vector of linear daily natural mortality rates (completely made up for now - REVISIT THIS LATER)

# Totally arbitrary mortality rates for each size class
N_mortality <- c("small" = 0.002,
                  "medium" = 0.001,
                  "large" = 0.001,
                  "xlarge" = 0.003)


daily_mortality_fun <- function(pop) {
  # Creating empty vector to hold IDs fo dead snakes
  dead_snakes <- vector()
  # Loop to apply Bernoulli function to each snake to see how many survive
  for(snake in 1:nrow(pop)) {
    if(pop$SVL[snake] <= 850) {
      if (rbinom(1, 1, prob = N_mortality[1]) == 1) { 
        dead_snakes[snake] <- pop$ID[snake]
      }
    } else if (pop$SVL[snake] > 850 & pop$SVL[snake] <= 950) {
      if (rbinom(1, 1, prob = N_mortality[2]) == 1) { 
        dead_snakes[snake] <- pop$ID[snake]
      }
    } else if (pop$SVL[snake] > 950 & pop$SVL[snake] <= 1150) {
      if (rbinom(1, 1, prob = N_mortality[3]) == 1) { 
        dead_snakes[snake] <- pop$ID[snake]
      } 
    } else if (pop$SVL[snake] > 1150) {
      if (rbinom(1, 1, prob = N_mortality[4]) == 1) { 
        dead_snakes[snake] <- pop$ID[snake]
      }
    }
  }
  # Get rid of NAs in dead snake ID vector
  dead_snakes <- dead_snakes[!is.na(dead_snakes)]
  
  # Extract surviving snakes 
  pop_2 <- pop[!pop$ID %in% dead_snakes,]
}


# Test
# y <- daily_mortality_fun(timeseries_pop[[1]])


```

```{r gen_model_toy}

set.seed(18)

# Setting up initial population:
init_pop <- as.data.frame(matrix(NA, nrow = 25, ncol = 3))
colnames(init_pop) <- c("ID", "SVL", "sex")

init_pop$ID <- paste0("A", sample(1000:9000, 25))
init_pop$SVL <- c(sample(350:850, 10), sample(851:950, 5), sample(951:1150, 5), sample(1151:1600, 5)) # initial size dist is 40% small, and 20% medium, large and x-large
init_pop$sex <- sample(c("M", "F"), 25, replace = T)

# Density parameter; probability of coin flip; 1 means snake grows, 0 means it doesn't
g_density_prob <- 0.75 # to operate stochastically, growth can't be 100% guaranteed

# Density parameter; probability of coin flip; 1 means snake grows, 0 means it doesn't
r_density_prob <- 0.75 # to operate stochastically, reproduction can't be 100% guaranteed

# Two time steps will be used, one for days in the quarter and the other for number of quarters, which is initially set to 4 (one year)
day_time_step <- 90
quarter_time_step <- 4

# Empty lists to put population from each time step in (initially recording everything, eventually I'll only need one, for the quarter time step)
quarter_timeseries_pop <- list()
daily_timeseries_pop <- list()

# Just growing individuals - first step, do they grow? Bernoulli (density dependent - start with no density dependence, so yes they grow), then if yes, how much do they grow? Normal or Gamma, maybe? Oh, don't want growth to be negative, so not normal - maybe gamma would work

# Setting up first population
quarter_timeseries_pop[[1]] <- init_pop
# Setting up empty dataframe to record IDs for reproducing females in each quarter
repro_females_timeseries <- list()

for(quarter in 1:quarter_time_step) {
  # Isolate reproducing females for this quarter; after first quarter, check for the females   who reproduced last quarter and skip them this quarter
  if (quarter == 1) {
    moms <- repro_females_fun(start_pop = quarter_timeseries_pop[[quarter]],
                            density_prob = r_density_prob)
  } else {
    recent_mom_IDs <- repro_females_timeseries[[quarter - 1]]$ID
    moms <- repro_females_fun(start_pop = quarter_timeseries_pop[[quarter]][!quarter_timeseries_pop[[quarter]]$ID %in% recent_mom_IDs,],
                            density_prob = r_density_prob)
  }
  
  # Producing new offspring to join population at the end   of the quarter
  offspring <- gen_offspring_fun(mom_pop = moms,
                              time_step = quarter)
  # Excluding reproducing females from population about to go through growth and mortality   for the quarter
  daily_timeseries_pop[[1]] <- quarter_timeseries_pop[[quarter]][!quarter_timeseries_pop[[quarter]]$ID %in% moms$ID, ]
  # Producing daily growth and mortality for 90 days
  for(day in 1:(day_time_step-1)) {
  pop <- daily_timeseries_pop[[day]]
  for(snake in 1:nrow(pop)) {
    pop[snake,] <- daily_growth_fun(pop[snake,], 
                                   g_density_prob,
                                   growth_rate)
  }
  surviving_pop <- daily_mortality_fun(pop)
  daily_timeseries_pop[[day + 1]] <- surviving_pop
  }     
  names(daily_timeseries_pop) <- paste0("day_", c(1:day_time_step))
  
  # Adding offspring and the reproducing females back into the surviving and grown general   population to be the start of the next quarter
  quarter_timeseries_pop[[quarter + 1]] <- rbind(daily_timeseries_pop[[day_time_step]], moms, offspring)
  
  # Keeping track of which females reproduced in which quarters (next step will be to use     this to exclude females who've reproduced in the last 2 quarters)
  repro_females_timeseries[[quarter]] <- moms
}



# Melting daily timeseries (only the 90 days in the final quarter) into a single dataframe
all_days <- melt(daily_timeseries_pop, id.vars = c("ID", "sex"))
colnames(all_days)[4:5] <- c("SVL", "time_step")
all_days$time_step <- factor(all_days$time_step, levels = names(daily_timeseries_pop))

# Melt quarter timeseries into a single dataframe
all_quarters <- melt(quarter_timeseries_pop, id.vars = c("ID", "sex"))
colnames(all_quarters)[4:5] <- c("SVL", "Quarter")

# Adding size distribution to combined quarters dataframe
for(snake in 1:nrow(all_quarters)) {
  if(all_quarters$SVL[snake] <= 850) {
    all_quarters$size_category[snake] <- "small"
  } else if(all_quarters$SVL[snake] > 850 & all_quarters$SVL[snake] <= 950) {
    all_quarters$size_category[snake] <- "medium"
  } else if(all_quarters$SVL[snake] > 950 & all_quarters$SVL[snake] <= 1150) {
    all_quarters$size_category[snake] <- "large"
  } else {
    all_quarters$size_category[snake] <- "xlarge"
  }
}
# Factoring size category column for graphing
all_quarters$size_category <- factor(all_quarters$size_category, 
                                     levels = c("small", "medium", "large", "xlarge"))

# Plotting results for individual snake growth for daily timeseries
ggplot(all_days, aes(x = time_step, y = SVL, color = ID)) +
  geom_point()

# Plotting all results for individual snake growth over quarter timeseries
ggplot(all_quarters, aes(x = Quarter, y = SVL, color = ID)) +
  geom_point() +
  geom_line()

# Plotting the total population in each quarter
ggplot(all_quarters, aes(x = Quarter, fill = size_category)) +
  geom_bar()

# Isolating and graphing one snake
snake <- all_days[all_days$ID == all_days$ID[22],]
ggplot(snake, aes(x = time_step, y = SVL)) +
  geom_point() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))



```

Now that the toy version is working (with 25 individuals), now to try it with a few hundred, for a slightly more realistic version to see how long it takes to run.

Running the model for 20 years (80 quarters) with an initial population of 300 took just under 5 minutes.

```{r full_gen_model}

set.seed(89)

# Initial population size:
init_N <- 300

# Initial size distribution:
init_size_dist <- c("small" = 0.4,
                    "medium" = 0.2,
                    "large" = 0.2,
                    "xlarge" = 0.2)

# Setting up initial population:
init_pop <- as.data.frame(matrix(NA, nrow = init_N, ncol = 3))
colnames(init_pop) <- c("ID", "SVL", "sex")

init_pop$ID <- paste0("A", sample(1000:9000, init_N))
init_pop$SVL <- c(sample(350:850, (init_N*init_size_dist[1])), 
                  sample(851:950, (init_N*init_size_dist[2])), 
                  sample(951:1150, (init_N*init_size_dist[3])), 
                  sample(1151:1600, (init_N*init_size_dist[4]))) 
init_pop$sex <- sample(c("M", "F"), init_N, replace = T)

# Density parameter; probability of coin flip; 1 means snake grows, 0 means it doesn't
g_density_prob <- 0.75 # to operate stochastically, growth can't be 100% guaranteed

# Density parameter; probability of coin flip; 1 means snake grows, 0 means it doesn't
r_density_prob <- 0.75 # to operate stochastically, reproduction can't be 100% guaranteed

# Two time steps will be used, one for days in the quarter and the other for number of quarters, which is initially set to 4 (one year)
day_time_step <- 90
quarter_time_step <- 80 # 20 years


# Empty lists to put population from each time step in (initially recording everything, eventually I'll only need one, for the quarter time step)
quarter_timeseries_pop <- list()
daily_timeseries_pop <- list()

# Setting up first population
quarter_timeseries_pop[[1]] <- init_pop
# Setting up empty dataframe to record IDs for reproducing females in each quarter
repro_females_timeseries <- list()

for(quarter in 1:quarter_time_step) {
  # Isolate reproducing females for this quarter; after first quarter, check for the females   who reproduced last quarter and skip them this quarter
  if (quarter == 1) {
    moms <- repro_females_fun(start_pop = quarter_timeseries_pop[[quarter]],
                            density_prob = r_density_prob)
  } else {
    recent_mom_IDs <- repro_females_timeseries[[quarter - 1]]$ID
    moms <- repro_females_fun(start_pop = quarter_timeseries_pop[[quarter]][!quarter_timeseries_pop[[quarter]]$ID %in% recent_mom_IDs,],
                            density_prob = r_density_prob)
  }
  
  # Producing new offspring to join population at the end   of the quarter
  offspring <- gen_offspring_fun(mom_pop = moms,
                              time_step = quarter)
  # Excluding reproducing females from population about to go through growth and mortality   for the quarter
  daily_timeseries_pop[[1]] <- quarter_timeseries_pop[[quarter]][!quarter_timeseries_pop[[quarter]]$ID %in% moms$ID, ]
  # Producing daily growth and mortality for 90 days
  for(day in 1:(day_time_step-1)) {
  pop <- daily_timeseries_pop[[day]]
  for(snake in 1:nrow(pop)) {
    pop[snake,] <- daily_growth_fun(pop[snake,], 
                                   g_density_prob,
                                   growth_rate)
  }
  surviving_pop <- daily_mortality_fun(pop)
  daily_timeseries_pop[[day + 1]] <- surviving_pop
  }     
  names(daily_timeseries_pop) <- paste0("day_", c(1:day_time_step))
  
  # Adding offspring and the reproducing females back into the surviving and grown general   population to be the start of the next quarter 
  quarter_timeseries_pop[[quarter + 1]] <- rbind(daily_timeseries_pop[[day_time_step]], moms, offspring)
  
  # Keeping track of which females reproduced in which quarters 
  repro_females_timeseries[[quarter]] <- moms
}



# Melting daily timeseries (only the 90 days in the final quarter are saved) into a single dataframe
all_days <- melt(daily_timeseries_pop, id.vars = c("ID", "sex"))
colnames(all_days)[4:5] <- c("SVL", "time_step")
all_days$time_step <- factor(all_days$time_step, levels = names(daily_timeseries_pop))

# Melt quarter timeseries into a single dataframe
all_quarters <- melt(quarter_timeseries_pop, id.vars = c("ID", "sex"))
colnames(all_quarters)[4:5] <- c("SVL", "Quarter")

# Adding size distribution to combined quarters dataframe
for(snake in 1:nrow(all_quarters)) {
  if(all_quarters$SVL[snake] <= 850) {
    all_quarters$size_category[snake] <- "small"
  } else if(all_quarters$SVL[snake] > 850 & all_quarters$SVL[snake] <= 950) {
    all_quarters$size_category[snake] <- "medium"
  } else if(all_quarters$SVL[snake] > 950 & all_quarters$SVL[snake] <= 1150) {
    all_quarters$size_category[snake] <- "large"
  } else {
    all_quarters$size_category[snake] <- "xlarge"
  }
}
# Factoring size category column for graphing
all_quarters$size_category <- factor(all_quarters$size_category, 
                                     levels = c("small", "medium", "large", "xlarge"))

# # Plotting results for individual snake growth for daily timeseries
# # Subsetting randomly to get a smaller number of snakes (dol)
# 
# ggplot(all_days_subset, aes(x = time_step, y = SVL, color = ID)) +
#   geom_point()
# 
# # Plotting all results for individual snake growth over quarter timeseries, for subset (plotting all )
# ggplot(all_quarters, aes(x = Quarter, y = SVL, color = ID)) +
#   geom_point() +
#   geom_line()

# Plotting the total population and size distribution in each quarter
ggplot(all_quarters, aes(x = Quarter, fill = size_category)) +
  geom_bar()

# Isolating and graphing one snake
snake <- 
ggplot(snake, aes(x = time_step, y = SVL)) +
  geom_point() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))


# Saving the first version with 300 individuals for 20 years (both the quarters and daily timeseries') to look at next week without having to re-run everything
saveRDS(quarter_timeseries_pop, file = here("Data/quarter_timeseries_3.3.23.rds"))
saveRDS(daily_timeseries_pop, file = here("Data/daily_timeseries_3.3.23.rds"))


## What proportion of females reproduced each quarter?
mom_rate <- vector()
for(quarter in 1:length(repro_females_timeseries)) {
  mom_rate[quarter] <- nrow(repro_females_timeseries[[quarter]])/nrow(quarter_timeseries_pop[[quarter + 1]][quarter_timeseries_pop[[quarter + 1]]$sex == "F", ])
}

summary(mom_rate) # mean = 12.4%, min = 8% and max = 29%

## How many offspring were added each quarter?
offspring_per_quarter <- vector()
for(quarter in 2:length(quarter_timeseries_pop)) {
  offspring_per_quarter[quarter - 1] <- nrow(quarter_timeseries_pop[[quarter]][!quarter_timeseries_pop[[quarter]]$ID %in% quarter_timeseries_pop[[quarter - 1]]$ID,])
}

summary(offspring_per_quarter) # mean = 72, min = 36 and max = 127

## How many died in each quarter?
mortality_rate <- vector()
for(quarter in 1:(length(quarter_timeseries_pop)-1)) {
  mortality_rate[quarter] <- 
    nrow(quarter_timeseries_pop[[quarter]][!quarter_timeseries_pop[[quarter]]$ID %in% quarter_timeseries_pop[[quarter + 1]]$ID,])/nrow(quarter_timeseries_pop[[quarter]])
}

summary(mortality_rate) # mean = 14%, min = 11% and max = 20% -- DEFINITELY too high

## What is the lifespan of individuals? (just the ones that have been born within the simulation - the burn in period in the future might be to run until the original individuals have all died)

lifespan_quarters <- vector()
# Excluding the original individuals
new_all_Qs <- all_quarters[-grep("A", all_quarters$ID),]
for(snake in 1:length(unique(new_all_Qs$ID))) {
  lifespan_quarters[snake] <- nrow(new_all_Qs[new_all_Qs$ID == new_all_Qs$ID[snake],])
}

summary(lifespan_quarters) # Mean = 12.5 (3.1 years), min = 1 and max = 65 (16.25 years)

# Maximum size reached (also only for snakes born in the simulation)
max_size <- vector()
for(snake in 1:length(unique(new_all_Qs$ID))) {
  max_size[snake] <- max(new_all_Qs$SVL[new_all_Qs$ID == new_all_Qs$ID[snake]])
}

summary(max_size) # Mean = 867.6, min = 351 and max = 2,056


```

### Varying starting population

Using different starting populations to see how the population performs through 20 years, with minimum population of 100 and max of 1000

```{r starting_pop_variation}

# Starting population list to iterate over 
N_options <- seq(100, 1100, 200) # 15 scenarios
# Vector of names for lists of results by starting population
SP_list_names <- paste0("SP_", N_options)

##### Parameters that won't change
# Initial size distribution:
init_size_dist <- c("small" = 0.4,
                    "medium" = 0.2,
                    "large" = 0.2,
                    "xlarge" = 0.2)
# Density parameter; probability of coin flip; 1 means snake grows, 0 means it doesn't
g_density_prob <- 0.75 # to operate stochastically, growth can't be 100% guaranteed

# Density parameter; probability of coin flip; 1 means snake grows, 0 means it doesn't
r_density_prob <- 0.75 # to operate stochastically, reproduction can't be 100% guaranteed

# Two time steps will be used, one for days in the quarter and the other for number of quarters, which is initially set to 4 (one year)
day_time_step <- 90
quarter_time_step <- 80 # 20 years

### Lists to store all quarter timeseries, final daily timeseries and reproducing female IDs for each quarter by starting population size as they change through time
all_quarter_timeseries <- list()
all_daily_timeseries <- list()
all_repro_females <- list()

### Loop for running full model with different starting populations (100 - 1,100)
for(init_N in 1:length(N_options)) {
  # Setting up initial population:
  init_pop <- as.data.frame(matrix(NA, nrow = N_options[init_N], ncol = 3))
  colnames(init_pop) <- c("ID", "SVL", "sex")
  # Creating unique IDs, randomly sampled sizes with specified size distribution, and     randomly selected sex
  init_pop$ID <- paste0("A", sample(1000:9000, N_options[init_N]))
  init_pop$SVL <- c(sample(350:850, (N_options[init_N]*init_size_dist[1]), replace = T), 
                  sample(851:950, (N_options[init_N]*init_size_dist[2]), replace = T), 
                  sample(951:1150, (N_options[init_N]*init_size_dist[3]), replace = T), 
                  sample(1151:1600, (N_options[init_N]*init_size_dist[4]), replace = T)) 
  init_pop$sex <- sample(c("M", "F"), N_options[init_N], replace = T)
  
  # Empty lists to put population from each time step in (initially recording everything, eventually I'll only need one, for the quarter time step)
  quarter_timeseries <- list()
  daily_timeseries <- list()

  # Setting up first population
  quarter_timeseries[[1]] <- init_pop
  # Setting up empty dataframe to record IDs for reproducing females in each quarter
  repro_females <- list()
  
  ### Running through timeseries (quarters, and days within each quarter)
  for(quarter in 1:quarter_time_step) {
  # Isolate reproducing females for this quarter; after first quarter, check for the females   who reproduced last quarter and skip them this quarter
  if (quarter == 1) {
    moms <- repro_females_fun(start_pop = quarter_timeseries[[quarter]],
                            density_prob = r_density_prob)
  } else {
    recent_mom_IDs <- repro_females[[quarter - 1]]$ID
    moms <- repro_females_fun(start_pop = quarter_timeseries[[quarter]][!quarter_timeseries[[quarter]]$ID %in% recent_mom_IDs,],
                            density_prob = r_density_prob)
  }
  
  # Producing new offspring to join population at the end   of the quarter
  offspring <- gen_offspring_fun(mom_pop = moms,
                              time_step = quarter)
  # Excluding reproducing females from population about to go through growth and mortality   for the quarter
  daily_timeseries[[1]] <- quarter_timeseries[[quarter]][!quarter_timeseries[[quarter]]$ID %in% moms$ID, ]
  # Producing daily growth and mortality for 90 days
  for(day in 1:(day_time_step-1)) {
  pop <- daily_timeseries[[day]]
  for(snake in 1:nrow(pop)) {
    pop[snake,] <- daily_growth_fun(pop[snake,], 
                                   g_density_prob,
                                   growth_rate)
  }
  surviving_pop <- daily_mortality_fun(pop)
  daily_timeseries[[day + 1]] <- surviving_pop
  }     
  names(daily_timeseries) <- paste0("day_", c(1:day_time_step))
  
  # Adding offspring and the reproducing females back into the surviving and grown general   population to be the start of the next quarter 
  quarter_timeseries[[quarter + 1]] <- rbind(daily_timeseries[[day_time_step]], 
                                             moms, offspring)
  
  # Keeping track of which females reproduced in which quarters 
  repro_females[[quarter]] <- moms
  }
  
  # Saving last day, quarter and reproducing mom IDs to appropriate lists
  all_quarter_timeseries[[init_N]] <- quarter_timeseries
  all_daily_timeseries[[init_N]] <- daily_timeseries
  all_repro_females[[init_N]] <- repro_females
}

names(all_quarter_timeseries) <- SP_list_names
names(all_daily_timeseries) <- SP_list_names
names(all_repro_females) <- SP_list_names

## Saving all lists 
saveRDS(all_quarter_timeseries, here("Data/start_pop_all_quarters.rds"))
saveRDS(all_daily_timeseries, here("Data/start_pop_all_daily.rds"))
saveRDS(all_repro_females, here("Data/start_pop_all_repro_females.rds"))

## Creating and saving plots to compare model performance at different starting populations

for(N in 1:length(N_options)) {
  # Melt quarter timeseries into a single dataframe
  all_quarters <- melt(all_quarter_timeseries[[N]], id.vars = c("ID", "sex"))
  colnames(all_quarters)[4:5] <- c("SVL", "Quarter")

  # Adding size distribution to combined quarters dataframe
  for(snake in 1:nrow(all_quarters)) {
    if(all_quarters$SVL[snake] <= 850) {
    all_quarters$size_category[snake] <- "small"
    } else if(all_quarters$SVL[snake] > 850 & all_quarters$SVL[snake] <= 950) {
    all_quarters$size_category[snake] <- "medium"
    } else if(all_quarters$SVL[snake] > 950 & all_quarters$SVL[snake] <= 1150) {
    all_quarters$size_category[snake] <- "large"
    } else {
    all_quarters$size_category[snake] <- "xlarge"
    }
  }
  # Factoring size category column for graphing
  all_quarters$size_category <- factor(all_quarters$size_category, 
                                     levels = c("small", "medium", "large", "xlarge"))
  
  # Plotting the total population and size distribution in each quarter
  plot <- ggplot(all_quarters, aes(x = Quarter, fill = size_category)) +
    geom_bar()
  # Saving plot
  ggsave(paste0(here("Results/starting_pop_"), SP_list_names[N], "_ts_plot.png"))
}



```
