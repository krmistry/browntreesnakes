---
title: "Individual-based Generating Model"
author: "Kelly Mistry"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(reshape2)
library(ggplot2)
```

## Individual-based Generating Model

Initial conditions and rough model structure:

-   25 individuals to start (to run faster)

-   Time step is days

-   In each time step, each individual:

    -   Has a probability of growing (Poisson based on the Gompertz growth function? Not quite sure yet, start with a static value as the Poisson lambda)

        -   Maybe this should be a Bernoulli too - sometimes there's no growth, and that could be relatively easy to add density dependence to; $p$ would change based on the density, so the probability of growing at all changes, independent of the actual growth rate

    -   Has a probability of reproducing (Bernoulli, then Poisson for number of offspring? Or just Poisson?)

        -   Same as for growth, having a Bernoulli element might make density dependence easier to incorporate

    -   Has a probability of dying from natural causes (Bernoulli)

-   Initial run time is 90 days (\~1 quarter); may need to run it longer to get much population movement, but start with this

```{r growth_function}

## This first version has linear growth, and the entire function will probably change when I get around to making growth non-linear (with the Gompertz functions from the growth paper)

## Inputs
# smale - 1 snake, i.e. one row of dataframe of current population (columns are ID, sex and size)
# density_prob - probability (0 - 1) for the Bernoulli probability for whether or not growth occurs
# growth_rates - dataframe of 3 linear growth rates (for small, medium and large snakes' growth) for each sex, constructed using Nafus et al. 2021 values ---- THIS WILL CHANGE


## Growth rates for linear, size-based growth (based on Nafus et al. 2021 rates, which were distinct for these size bins: <750, 750 - 1000 and >1000 (different from my size bins)
growth_rate <- as.data.frame(matrix(NA, nrow = 3, ncol = 2, 
                                    dimnames = list(c("small", "medium", "large"),
                                                    c("M", "F"))))
growth_rate[1, ] <- c(1.18, 0.98) # less than 750 mm SVL
growth_rate[2, ] <- c(0.56, 0.46) # 750 - 999
growth_rate[3, ] <- c(0.52, 0.29) # greater than or equal to 1,000 

daily_growth_fun <- function(snake, 
                             density_prob,
                             growth_rate) {
  if (rbinom(1, 1, prob = density_prob) == 1) {
      if (snake$SVL < 750) {
        if (snake$sex == "M") {
          snake$SVL <- snake$SVL + growth_rate[1, 1]
        } else {
          snake$SVL <- snake$SVL + growth_rate[1, 2]
        }
      } else if (snake$SVL >= 750 & snake$SVL < 1000) {
        if (snake$sex == "M") {
          snake$SVL <- snake$SVL + growth_rate[2, 1]
        } else {
          snake$SVL <- snake$SVL + growth_rate[2, 2]
        }
      } else {
        if (snake$sex == "M") {
          snake$SVL <- snake$SVL + growth_rate[3, 1]
        } else {
          snake$SVL <- snake$SVL + growth_rate[3, 2]
        }
      }
    } else {
      snake$SVL <- snake$SVL
    }
  return(snake)
}


# Test
# daily_growth_fun(timeseries_pop[[1]][1, ], 
#                             0.75,
#                             growth_rate)

```

```{r reproduction_fun}

## Reproduction - occurs every 90 days; two ways to do this, either in one step or two. In the two step version, the first step is do they reproduce? Then, if they do, the number of offspring comes from a Poisson distribution. Same as with growth, this might make density dependence easier to incorporate by doing this in the first step. Alternatively, this could be done in a single step, with a draw from a Poisson, after isolating the females that could reproduce size-wise

### Inputs
# start_pop <- dataframe of population at the start of the quarter (columns are ID, sex and size)
# density_prob - probability (0 - 1) for the Bernoulli probability for whether or not snake reproduces in this quarter

repro_function <- function(start_pop,
                           density_prob) {
  # Extracting the females from this population
  females <- start_pop[start_pop$sex == "F",]
  # Setting up the probability of reproduction for each snake based on their size
  # For now, it's based on Savidge et al. 2007 findings, which indicated that 90% of female   snakes reached sexual maturity between 910 and 1,025 SVL (doesn't mean that each            snake has a 90% probability of reproducing in that quarter though - LOOK AT THIS   AGAIN    LATER, it definitely needs to be revised)
  for(snake in 1:nrow(females)) {
    if(females$SVL[snake] < 910) {
      females$repro_prob[snake] <- 0
    } else if (females$SVL[snake] >= 910 & females$SVL[snake] < 1025) {
      females$repro_prob[snake] <- 0.9
    } else {
      females$repro_prob[snake] <- 1
    }
  }
  # Two step version, with a coin flip for whether or not reproduction occurs
  for(snake in 1:nrow(females)) {
    # Coin flip of whether reproduction occurs is based on both density dependence and the     probablity that the individual snake will be able to reproduce based on it's size
    if (rbinom(1, 1, prob = r_density_prob*females$repro_prob[snake]) == 1) {
      females$mom_status[snake] <- 1
    } else {
      females$mom_status[snake] <- 0
    }
  }
  # Version one - using the same value for lambda for all sizes (could separate this out      into size buckets, or maybe even could make it continuous based on Nafus data)
  total_offspring <- sum(rpois(sum(females$mom_status), 2.3))
  # Creating empty dataframe to put offspring data into
  offspring <- as.data.frame(matrix(NA, nrow = total_offspring, ncol = 3))
  colnames(offspring) <- c("ID", "SVL", "sex")
  # Filling in IDs, hatchling size (with some variation) and random sex
  offspring$ID <- paste0("B", sample(1000:9000, total_offspring))
  offspring$SVL <- sample(350:400, total_offspring)
  offspring$sex <- sample(c("M", "F"), total_offspring, replace = T)
  
  ## Combining the offspring with mothers and return as one dataframe
  new_pop <- rbind(females[,c(1:3)], offspring)
  return(new_pop)
}  


# Test
# x <- repro_function(timeseries_pop[[1]],
#                0.75)


```

```{r mortality_fun}

# Function to incorporate daily mortality rate (completely arbitrary linear rates for now, based on my original size classes)

## Natural mortality - using one day timeseries (post-growth) and size-based mortality rates (current version is that the probability is constant for each of the size-structured model size bins, and the first version here is totally arbitrary)

### Inputs
# pop - dataframe of population (columns are ID, sex and size)
# mortality_rate - vector of linear daily natural mortality rates (completely made up for now - REVISIT THIS LATER)

# Totally arbitrary mortality rates for each size class
N_mortality <- c("small" = 0.02,
                  "medium" = 0.01,
                  "large" = 0.01,
                  "xlarge" = 0.03)


daily_mortality_fun <- function(pop) {
  # Creating empty vector to hold IDs fo dead snakes
  dead_snakes <- vector()
  # Loop to apply Bernoulli function to each snake to see how many survive
  for(snake in 1:nrow(pop)) {
    if(pop$SVL[snake] <= 850) {
      if (rbinom(1, 1, prob = N_mortality[1]) == 1) { 
        dead_snakes[snake] <- pop$ID[snake]
      }
    } else if (pop$SVL[snake] > 850 & pop$SVL[snake] <= 950) {
      if (rbinom(1, 1, prob = N_mortality[2]) == 1) { 
        dead_snakes[snake] <- pop$ID[snake]
      }
    } else if (pop$SVL[snake] > 950 & pop$SVL[snake] <= 1150) {
      if (rbinom(1, 1, prob = N_mortality[3]) == 1) { 
        dead_snakes[snake] <- pop$ID[snake]
      } 
    } else if (pop$SVL[snake] > 1150) {
      if (rbinom(1, 1, prob = N_mortality[4]) == 1) { 
        dead_snakes[snake] <- pop$ID[snake]
      }
    }
  }
  # Get rid of NAs in dead snake ID vector
  dead_snakes <- dead_snakes[!is.na(dead_snakes)]
  
  # Extract surviving snakes 
  pop_2 <- pop[!pop$ID %in% dead_snakes,]
}


# Test
# y <- daily_mortality_fun(timeseries_pop[[1]])


```

```{r gen_model_toy}

set.seed(18)

# Setting up initial population:
init_pop <- as.data.frame(matrix(NA, nrow = 25, ncol = 3))
colnames(init_pop) <- c("ID", "SVL", "sex")

init_pop$ID <- paste0("A", sample(1000:9000, 25))
init_pop$SVL <- c(sample(350:850, 10), sample(851:950, 5), sample(951:1150, 5), sample(1151:1600, 5)) # initial size dist is 40% small, and 20% medium, large and x-large
init_pop$sex <- sample(c("M", "F"), 25, replace = T)

# Density parameter; probability of coin flip; 1 means snake grows, 0 means it doesn't
g_density_prob <- 0.75 # to operate stochastically, growth can't be 100% guaranteed

# Density parameter; probability of coin flip; 1 means snake grows, 0 means it doesn't
r_density_prob <- 0.75 # to operate stochastically, reproduction can't be 100% guaranteed

# Two time steps will be used, one for days in the quarter and the other for number of quarters, which is initially set to 4 (one year)
day_time_step <- 90
quarter_time_step <- 4

# Empty lists to put population from each time step in (initially recording everything, eventually I'll only need one, for the quarter time step)
quarter_timeseries_pop <- list()
daily_timeseries_pop <- list()

# Just growing individuals - first step, do they grow? Bernoulli (density dependent - start with no density dependence, so yes they grow), then if yes, how much do they grow? Normal or Gamma, maybe? Oh, don't want growth to be negative, so not normal - maybe gamma would work

# Setting up first population
quarter_timeseries_pop[[1]] <- init_pop

for(quarter in 1:quarter_time_step) {
  # Isolating reproducing females and producing new offspring to join population at the end   of the quarter
  moms_offspring <- repro_function(quarter_timeseries_pop[[quarter]],
                  r_density_prob)
  # Excluding reproducing females from population about to go through growth and mortality   for the quarter
  daily_timeseries_pop[[1]] <- quarter_timeseries_pop[!quarter_timeseries_pop[[quarter]]$ID %in% moms_offspring$ID, ]
  for(day in 1:(day_time_step-1)) {
  pop <- daily_timeseries_pop[[day]]
  for(snake in 1:nrow(pop)) {
    pop[snake] <- daily_growth_fun(pop[snake], 
                                   g_density_prob,
                                   growth_rate)
  }
  surviving_pop <- daily_mortality_fun(pop)
  daily_timeseries_pop[[day + 1]] <- surviving_pop
  }     
  names(daily_timeseries_pop) <- paste0("day_", c(1:daily_time_step))
  
  # Adding offspring and the reproducing females back into the surviving and grown general   population to be the start of the next quarter
  quarter_timeseries_pop[[quarter + 1]] <- rbind(daily_timeseries_pop[[day_time_step]], moms_offspring)
}




# Melting timeseries into a single dataframe
all_days <- melt(timeseries_pop, id.vars = c("ID", "sex"))
colnames(all_days)[4:5] <- c("SVL", "time_step")
all_days$time_step <- factor(all_days$time_step, levels = names(timeseries_pop))

# Plotting results
ggplot(all_days, aes(x = time_step, y = SVL, color = ID)) +
  geom_jitter()

# Isolating and graphing one snake
snake <- all_days[all_days$ID == all_days$ID[22],]
ggplot(snake, aes(x = time_step, y = SVL)) +
  geom_jitter() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))









```
