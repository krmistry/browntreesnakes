---
title: "Extended Generating Model"
author: "Kelly Mistry"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(fdrtool)
library(reshape2)
library(ggplot2)
library(tidyr)
```

## Generating Model of Brown Treesnakes

Size-structured model with 4 size classes, with small snakes being less than 850 mm SVL (with a lower limit of 350 mm SVL at hatching), medium snakes being between 850 and 1150 mm SVL, large snakes being between 1150 and 1250 mm SVL, and extra large snakes being larger than 1250 mm SVL (based on the size classes that Staci used).

A time step in this model is 3 months, and the simulated population is based on the expected population in a 55 hectare area (the size of the HMU, the site of an eradication experiment in the near future).

The parameters I am estimating are:

-   growth of individuals ($\alpha_i$) in $i$ size class

-   reproduction ($r_i$) in $i$ size class

-   natural mortality ($d_i$) in $i$ size class

The entire population in time step $t$ ($N_t$) is defined as:

$$
N_t = \sum_{i = 1}^{4} n_{i,t}
$$

The population of the first size class in time step t ($n_{1,t}$), is defined as:

$$
n_{i,t} = [1 - (\alpha_1 + d_1)] n_{1,t-1} + \sum_{i=2}^{4} r_i*n_{i, t-1}  
$$

The second size classes in time step t ($n_{2,t}$) is defined as:

$$
n_{2,t} = [1-(\alpha_2 + d_2)]n_{2, t-1} + \alpha_1*n_{1,t-1}
$$

The third size classes in time step t ($n_{3,t}$) is defined as:

$$
n_{3,t} = [1-(\alpha_3 + d_3)]n_{3, t-1} + \alpha_2*n_{2,t-1}
$$

The fourth and final size class in time step t ($n_{4,t}$) is defined as:

$$
n_{4,t} = (1-d_4)n_{4,t-1} + \alpha_3*n_{3,t-1}
$$

#### Vital Rates

Growth rates are density dependent, using estimated carrying capacity ($K$) and peak *(or average, TBD)* growth rate for size class $i$ ($g_i$) constructed from the literature with a half normal relationship between density and growth. $n_t$ is the total population in time step $t$. Carrying capacity is used to construct the standard deviation of a half-normal distribution (with a mean of 0), $\theta$.

$$
\sigma = \frac{K*0.975}{1.96}
$$

$$
\theta =\frac{\sqrt{\pi/2}}{\sigma}
$$

Using this $\theta$, I calculated the probability density function of $n_t$ and scaled it by the PDF when density is 0, and then multiplied by the peak growth rate to produce a growth rate for size class $i$ at $n_t$, $g_{i, n_t}$. Using the PDF equation for a half-normal distribution with a mean of 0 and standard deviation $\theta$, this becomes:

$$
g_{n_t} = \frac{\frac{2\theta}{\pi}\exp(\frac{-n_t^2\theta^2}{\pi})}{\frac{2\theta}{\pi}\exp(\frac{0^2\theta^2}{\pi})}*g
$$

$$
g_{n_t} = \frac{\exp(\frac{-n_t^2\theta^2}{\pi})}{\exp(0)}*g
$$

$$
g_{n_t} = \exp(\frac{-n_t^2\theta^2}{\pi})*g
$$

Reproductive rates are also density dependent, and are calculated in the same way as growth rate, with peak reproductive rates for each size class constructed from the literature.

Natural mortality rates are constant for each size class, $d_i$, and are constructed from the literature.

**Details about how natural mortality, peak (or average) growth and reproductive rates were constructed from literature review can be found in vital_rates_lit_review.Rmd doc.**

```{r vital_rates_fun}


##### Vital rates function - use for both growth and reproductive rates

rates_fun <- function(carrying_capacity, 
                      peak_vital_rate,
                      current_density) {
  # Calculate sigma for scaling standard deviation using carrying capacity
  sd <- (carrying_capacity*0.975)/1.96
  # Calculate PDF when density is 0 (highest density probability value)
  max_prob_value <- dhalfnorm(0, theta = ((sqrt(pi/2))/sd))
  # Calculate PDF value for the current density
  PDf_value <- dhalfnorm(current_density, theta = ((sqrt(pi/2))/sd))
  # Use maximum value to scale current density's PDF value, and multiply by the peak vital rate
  rate <- (PDf_value/max_prob_value)*peak_vital_rate
  return(rate)
}

# Testing:
# x <- rates_fun(carrying_capacity = 6000, # from 116 snakes/hectare for 55 hectares
#           peak_vital_rate = 0.09216, # peak growth rate for small & medium sizes
#           current_density = 1000) 

```

```{r generating_model_fun}

### Function to generate population for all size classes in next time step 
generate_fun <- function(t_minus_1,# The previous time step data (1 row, 4 columns for each size class)
                            growth, # growth rate vector for 3 smaller size classes
                            mortality, # mortality rate vector for all size classes
                            reproduction) { # reproductive rate vector for 3 larger size classes
  # Create vector to hold the current time step's population numbers
  t <- vector() 
  # Calculate small class population
  t[1] <- (1-(growth[1] + mortality[1]))*t_minus_1[, 1] + 
    reproduction[1]*t_minus_1[, 2] + 
    reproduction[2]*t_minus_1[, 3] +
    reproduction[3]*t_minus_1[, 4]
  # Calculate medium class population
  t[2] <- (1-(growth[2] + mortality[2]))*t_minus_1[, 2] +
    growth[1]*t_minus_1[, 1]
  # Calculate large class population
  t[3] <- (1-(growth[3] + mortality[3]))*t_minus_1[, 3] +
    growth[2]*t_minus_1[, 2]
  # Calculate x-large class population
  t[4] <- (1 - mortality[4])*t_minus_1[, 4] +
    growth[3]*t_minus_1[, 3]
  
  return(t)
}


 growth <- rates_fun(carrying_capacity = 6000, # from 116 snakes/hectare for 55 hectares
          peak_vital_rate = growth_peak_rates[1], # peak growth rate for small & medium sizes
          current_density = 1000) 

# reproduction <- rates_fun(carrying_capacity = 6000, # from 116 snakes/hectare for 55 hectares
#           peak_vital_rate = 0.09216, # peak growth rate for small & medium sizes
#           current_density = 1000) 


```


```{r population}

# Loading vital rates parameters constructed from literature (per Vital_rates_lit_review.Rmd)
rates_list <- readRDS("vital_rates_lit.rds")

# Number of years to simulate (with 4 time steps per year)
Year <- 20

# Starting population
N <- 6000

# Size classes
bins <- c("small",
          "medium",
          "large",
          "xlarge")
n_bins <- length(bins)

# List of empty matrices to fill with growth and reproduction values drawn for each size class in each year
vital_rates <- list()
vital_rates$growth <- as.data.frame(matrix(NA, nrow = Year*4, ncol = 3))
# vital_rates$repro <- as.data.frame(matrix(NA, nrow = Year*4, ncol = 3))

# Empty matrix to fill with population results for a 20 year timeseries
# A column for each size class, plus a totals column
timeseries <- as.data.frame(matrix(NA, nrow = Year*4, ncol = n_bins+1))
colnames(timeseries) <- c(bins, "total")

# Time 0 in first row
timeseries[1, ] <- c(rep(N/4, 4), N)

for(ts in 2:(Year*4)) {
  # Generate growth rate for this year
  vital_rates$growth[ts-1, ] <- rates_fun(carrying_capacity = 6000,
          peak_vital_rate = growth_peak_rates,
          current_density = timeseries$total[ts-1])
  # Generate next time step populations
  timeseries[ts, 1:4] <- generate_fun(t_minus_1 = timeseries[ts-1,],
                                       growth = vital_rates$growth[ts-1, ],
                                       mortality = mortality_vector,
                                       reproduction = repro_vector)
  timeseries$total[ts] <- sum(timeseries[ts, 1:4])
}

# Adding year and quarter columns
timeseries$year <- rep(1:Year, each = 4)
timeseries$quarter <- rep(paste0("Q", 1:4), Year)

### Plotting all populations to see what's happening

# Melt matrix to make plotting easier
tm_plot <- melt(timeseries[, -5], id.vars = c("year", "quarter"))
colnames(tm_plot)[3:4] <- c("size", "pop")

ggplot(tm_plot, aes(fill = quarter, y = pop, x = year)) +
  geom_bar(position="dodge", stat="identity") +
  facet_wrap(vars(size)) +
  theme_bw()


## Plotting growth rates for each size class
colnames(vital_rates$growth) <- bins[-4]
vital_rates$growth$year <- rep(1:Year, each = 4)
vital_rates$growth$quarter <- rep(paste0("Q", 1:4), Year)

growth_rates_plots <- melt(vital_rates$growth[-80,], id.vars = c("year", "quarter"))
colnames(growth_rates_plots)[3:4] <- c("size", "growth_rate")

ggplot(growth_rates_plots, aes(x = year, y = growth_rate, fill = quarter)) +
  geom_bar(position = "dodge", stat = "identity")+
  facet_wrap(vars(size)) +
  theme_bw()

## Plotting proportion of size classes in population
ggplot(tm_plot, aes(fill = size, y = pop, x = year)) +
  geom_bar(position="stack", stat="identity") +
  facet_wrap(vars(quarter)) +
  theme_bw()

  
```
